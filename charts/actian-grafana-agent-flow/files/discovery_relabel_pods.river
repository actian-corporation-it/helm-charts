// Arguments

// Targets must be a list(map(string)) that are discovered
argument "targets" {
	optional = false
}

export "output" {
	value = discovery.relabel.pods_common.output
}

// Discovery relabeling

// Actian Pods have different / non-standard labels per application / component
// Better to treat them separately
discovery.relabel "pods_actian" {
	targets = argument.targets.value

	rule {
		action        = "keep"
		regex         = "avalanche|databases|warehouses"
		source_labels = ["__meta_kubernetes_namespace"]
	}

	// rule {
	// 	replacement  = "discovery_relabel_pods_actian"
	// 	target_label = "flow_module_name_1"
	// }

	rule {
		source_labels = [
			"__meta_kubernetes_pod_label_release",
		]
		target_label = "__wh_name__"
	}

	rule {
		// Try to identify WH component name to eventually form the job label. We'll
		// prefer the first of the below labels, in descending order.
		source_labels = [
			"__meta_kubernetes_pod_label_component",
			"__meta_kubernetes_pod_label_app_kubernetes_io_name",
		]
		target_label = "__wh_component__"

		// Our in-memory string will be something like A;B;C;D;E;F, where any of the
		// letters could be replaced with a label value or be empty if the label
		// value did not exist.
		//
		// We want to match for the very first sequence of non-semicolon characters
		// which is either prefaced by zero or more semicolons, and is followed by
		// zero or more semicolons before the rest of the string.
		//
		// This is a very annoying way of being able to do conditionals, and
		// ideally we can use River expressions in the future to make this much
		// less bizarre.
		regex = ";*([^;]+);*.*"
	}

	rule {
		source_labels = [
			"__meta_kubernetes_namespace",
			"__wh_name__",
			"__wh_component__",
		]
		target_label = "job"
		separator    = "/"
	}
}

// Non-Actian pods will be treated in standard ways
discovery.relabel "pods_k8s" {
	targets = argument.targets.value

	rule {
		action        = "drop"
		regex         = "avalanche|databases|warehouses"
		source_labels = ["__meta_kubernetes_namespace"]
	}

	// rule {
	// 	replacement  = "discovery_relabel_pods_k8s"
	// 	target_label = "flow_module_name_2"
	// }

	// rule {
	// 	source_labels = [
	// 		"__meta_kubernetes_pod_label_app_kubernetes_io_name",
	// 	]
	// 	target_label = "__helm_name__"
	// 	separator    = "-"
	// 	regex        = "(.+-.+)"
	// }

	rule {
		// Try to identify a service name to eventually form the job label. We'll
		// prefer the first of the below labels, in descending order.
		source_labels = [
			"__meta_kubernetes_pod_label_name",
			"__meta_kubernetes_pod_label_app_kubernetes_io_name",
			"__meta_kubernetes_pod_label_k8s_app",
			"__meta_kubernetes_pod_label_app",
			"__meta_kubernetes_pod_label_app_kubernetes_io_instance",
			"__meta_kubernetes_pod_controller_name",
			"__meta_kubernetes_pod_name",
		]
		target_label = "__service__"

		// Our in-memory string will be something like A;B;C;D;E;F, where any of the
		// letters could be replaced with a label value or be empty if the label
		// value did not exist.
		//
		// We want to match for the very first sequence of non-semicolon characters
		// which is either prefaced by zero or more semicolons, and is followed by
		// zero or more semicolons before the rest of the string.
		//
		// This is a very annoying way of being able to do conditionals, and
		// ideally we can use River expressions in the future to make this much
		// less bizarre.
		regex = ";*([^;]+);*.*"
	}

	rule {
		source_labels = [
			"__meta_kubernetes_namespace",
			"__service__",
		]
		target_label = "job"
		separator    = "/"
	}
}

// After Actian and non-Actian pods prepared, apply common relabeling
discovery.relabel "pods_common" {
	targets = concat(
		discovery.relabel.pods_actian.output,
		discovery.relabel.pods_k8s.output,
	)

	// rule {
	// 	replacement  = "discovery_relabel_pods_common"
	// 	target_label = "flow_module_name_3"
	// }

	rule {
		source_labels = ["__meta_kubernetes_namespace"]
		target_label  = "namespace"
	}

	rule {
		source_labels = ["__meta_kubernetes_pod_name"]
		target_label  = "pod"
	}

	rule {
		source_labels = ["__meta_kubernetes_pod_container_name"]
		target_label  = "container"
	}
}
