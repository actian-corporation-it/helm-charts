// Arguments

// Targets must be a list(map(string)) of targets to scrape
argument "targets" {
	optional = false
}

// forward_logs_to must be a list(LogsReceiver) where log entries
// should be forwarded.
argument "forward_logs_to" {
	optional = false
}

// scrape_interval is a duration which specifies how frequently to collect
// metrics.
argument "scrape_interval" {
	optional = true
	default  = "30s"
}

// scrape_timeout is a duration which specifies how long to wait for a single
// metrics collection to complete.
argument "scrape_timeout" {
	optional = true
	default  = "10s"
}

// Processing

discovery.relabel "pods_logs" {
	targets = argument.targets.value

	rule {
		// Try to identify a service name to eventually form the job label. We'll
		// prefer the first of the below labels, in descending order.
		source_labels = [
			"__meta_kubernetes_pod_name",
			"__meta_kubernetes_pod_label_name",
			"__meta_kubernetes_pod_label_app",
			"__meta_kubernetes_pod_label_k8s_app",
			"__meta_kubernetes_pod_controller_name",
			"__meta_kubernetes_pod_label_component",
		]
		target_label = "__service__"

		// Our in-memory string will be something like A;B;C;D;E;F, where any of the
		// letters could be replaced with a label value or be empty if the label
		// value did not exist.
		//
		// We want to match for the very first sequence of non-semicolon characters
		// which is either prefaced by zero or more semicolons, and is followed by
		// zero or more semicolons before the rest of the string.
		//
		// This is a very annoying way of being able to do conditionals, and
		// ideally we can use River expressions in the future to make this much
		// less bizarre.
		regex = ";*([^;]+);*.*"
	}

	rule {
		action        = "drop"
		regex         = ""
		source_labels = [
			"__service__",
		]
	}

	// rule {
	// 	replacement  = "pod_logs"
	// 	target_label = "flow_module_name"
	// }

	rule {
		source_labels = [
			"__meta_kubernetes_namespace",
			"__service__",
		]
		target_label = "job"
		separator    = "/"
	}

	rule {
		source_labels = [
			"__meta_kubernetes_pod_node_name",
		]
		target_label = "__host__"
	}

	rule {
		source_labels = [
			"__meta_kubernetes_pod_uid",
			"__meta_kubernetes_pod_container_name",
		]
		target_label = "__path__"
		separator    = "/"
		replacement  = "/var/log/pods/*$1/*.log"
	}
}

discovery.file "pods_logs" {
	path_targets = discovery.relabel.pods_logs.output
}

loki.source.file "pods" {
	targets    = discovery.file.pods_logs.targets
	forward_to = argument.forward_logs_to.value
}
